Title: Rust での -1.abs()
Date: 2016-05-23 10:20
Category: Rust
Tags: rust
Authors: Hidemoto Nakada

# Rustでの -1.abs()

Rustでは、C++やJavaと違って、組み込み型に対してメソッドを定義する事ができる。
なので、i32の変数aの絶対値を求めるには、

```
a.abs();
```
のように書ける。すばらしい。

しかしここで落とし穴が１つ。
```
-1.abs();
```
とすると、答えが-1になる。なぜか。
 
`-1`は、なんとなく1つの不可分なリテラルのような気がしてしまうが、
単項前置演算子 `-` が数値リテラル`1`の前に付いたものだ。
したがって、`-1.abs()`が`(-1).abs()`となるか`-(1.abs())`となるかは、
演算子の優先順位によって定まる。そして、Rustではメソッド呼び出しの
優先順位のほうが単項演算子よりも高いので、後者として解釈されるので、
答えが`-1`になるのだ。

ちなみに、演算子の優先順位は基本的にC++を引き継いでいるので、順位は
C++でもJavaでも変わらない。C++やJavaでこれが問題にならないのは、
そもそも組み込み型に対してメソッドを定義できないからだろう。

まあ、`-a.abs()` なら `-(a.abs())`の方が自然なような気がするので
リテラルのときだけ気をつければ済む話ではある。

## Rubyでは

同様に整数型にメソッドが定義されている、Rubyはどうだろう。
```
$ irb
irb(main):001:0> -1.abs
=> 1
```
なんとびっくり。
Rubyではメソッド呼び出しはすべての演算子よりも優先順位が低いのだ。

それはそれで1つの見識という気もする。
